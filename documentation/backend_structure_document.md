# Backend Structure Document

## 1. Backend Architecture

We’ve built the backend around a serverless-friendly Node.js application with TypeScript and Supabase at its core. Here’s how it all fits together:

• **Design patterns and frameworks**

*   Serverless API routes (via Next.js) for handling business logic in small, maintainable functions
*   Repository pattern for database access, keeping SQL queries and models organized
*   Event‐driven updates for real-time features, using WebSockets

• **Scalability**

*   Each API route runs independently, so traffic spikes in one area (e.g. feedback submission) don’t slow down others
*   Supabase’s managed PostgreSQL scales vertically and horizontally as our data grows
*   WebSocket connections shard across serverless instances, and we can add more capacity on demand

• **Maintainability**

*   Clear separation of concerns: auth, database, business logic, and external services (OpenAI, Stripe) are each in their own folder
*   TypeScript types keep API inputs and outputs explicit and reduce bugs

• **Performance**

*   On-demand functions spin up quickly for low cold-start times
*   Supabase caching and indexing speed up common queries (e.g. loading roadmap items)
*   WebSocket channel updates push only diffs to clients, minimizing data transfer

## 2. Database Management

We use Supabase’s hosted PostgreSQL database along with Supabase Auth for user management.

• **Database type**: Relational (PostgreSQL) • **Auth**: Supabase Auth (email/password + social logins) • **Data structure and access**

*   Tables for users, projects (roadmaps), feedback items, votes, comments, subscriptions, AI suggestions, social posts, and embed configurations
*   Role-based row‐level security (RLS) policies in Postgres: founders vs. contributors vs. moderators
*   Connection pooling managed by Supabase for high concurrency • **Data management practices**
*   Daily automated backups
*   Indexed columns on frequently filtered fields (project_id, user_id, status)
*   Soft deletes (boolean `is_deleted`) for GDPR‐compliant data removal

## 3. Database Schema

Below is a high‐level, human‐readable summary of our main tables followed by the SQL definitions.

### Tables Overview (human‐readable)

• **Users**: Stores founder and contributor profiles, login methods, roles • **Projects**: Each public roadmap owned by a founder, with its title, description, and settings • **Feedback**: Suggestions and feature requests submitted by community members • **Votes**: Tracking upvotes on feedback items by user or anonymous handle • **Comments**: Threaded comments on feedback items • **AI_Suggestions**: Clusters and recommended roadmap items generated by OpenAI • **Social_Posts**: Auto‐generated messages for sharing roadmap updates on social media • **Subscriptions**: Stripe customer IDs, plan details, status, billing period end • **Embeds**: Configuration for the public widget embed (colors, default view)

### PostgreSQL Schema (SQL)

`-- USERS drop table if exists users cascade; create table users ( id uuid primary key default gen_random_uuid(), email text unique not null, name text, role text not null check (role in ('founder','contributor','moderator')), auth_provider text not null, created_at timestamptz default now(), is_deleted boolean default false ); -- PROJECTS (ROADMAPS) drop table if exists projects cascade; create table projects ( id uuid primary key default gen_random_uuid(), owner_id uuid references users(id), name text not null, description text, public_url text unique, created_at timestamptz default now(), is_deleted boolean default false ); -- FEEDBACK ITEMS drop table if exists feedback cascade; create table feedback ( id uuid primary key default gen_random_uuid(), project_id uuid references projects(id), author_id uuid references users(id) null, author_handle text, content text not null, status text default 'open', cluster_id uuid references ai_suggestions(id) null, created_at timestamptz default now(), is_deleted boolean default false ); -- VOTES drop table if exists votes cascade; create table votes ( id uuid primary key default gen_random_uuid(), feedback_id uuid references feedback(id), voter_id uuid references users(id) null, voter_handle text, created_at timestamptz default now() ); -- COMMENTS drop table if exists comments cascade; create table comments ( id uuid primary key default gen_random_uuid(), feedback_id uuid references feedback(id), author_id uuid references users(id) null, author_handle text, content text not null, created_at timestamptz default now(), is_deleted boolean default false ); -- AI SUGGESTIONS (CLUSTERS) drop table if exists ai_suggestions cascade; create table ai_suggestions ( id uuid primary key default gen_random_uuid(), project_id uuid references projects(id), prompt text, suggestions jsonb, created_at timestamptz default now() ); -- SOCIAL POSTS drop table if exists social_posts cascade; create table social_posts ( id uuid primary key default gen_random_uuid(), project_id uuid references projects(id), content text, platform text, scheduled_for timestamptz, created_at timestamptz default now() ); -- SUBSCRIPTIONS drop table if exists subscriptions cascade; create table subscriptions ( id uuid primary key default gen_random_uuid(), user_id uuid references users(id), stripe_customer_id text, stripe_subscription_id text, plan text, status text, current_period_end timestamptz, created_at timestamptz default now() ); -- EMBED SETTINGS drop table if exists embeds cascade; create table embeds ( id uuid primary key default gen_random_uuid(), project_id uuid references projects(id), theme_color text, default_view text check (default_view in ('now','next','later')), created_at timestamptz default now() );`

## 4. API Design and Endpoints

Our APIs follow a RESTful style, with JSON inputs and outputs. We secure routes with JWT tokens issued by Supabase Auth.

• **Auth**

*   POST `/api/auth/signup` – sign up with email/password or social
*   POST `/api/auth/login` – return JWT
*   POST `/api/auth/logout` – invalidate session

• **Projects (Roadmaps)**

*   GET `/api/projects` – list user’s projects
*   POST `/api/projects` – create a new roadmap
*   GET `/api/projects/{id}` – get roadmap details and public view
*   PUT `/api/projects/{id}` – update title, description

• **Feedback & Voting**

*   GET `/api/projects/{id}/feedback` – list feedback items
*   POST `/api/projects/{id}/feedback` – submit new feedback
*   POST `/api/feedback/{fid}/votes` – cast an upvote
*   GET `/api/feedback/{fid}/comments` – list comments
*   POST `/api/feedback/{fid}/comments` – add a comment

• **AI Insights**

*   POST `/api/projects/{id}/ai/cluster` – run clustering on feedback
*   GET `/api/projects/{id}/ai/suggestions` – retrieve saved AI suggestions

• **Social Sharing**

*   GET `/api/projects/{id}/social/templates` – fetch available templates
*   POST `/api/projects/{id}/social/schedule` – schedule a post

• **Subscriptions & Billing**

*   GET `/api/subscriptions` – fetch current plan
*   POST `/api/subscriptions/checkout` – create Stripe checkout session
*   POST `/api/webhooks/stripe` – handle Stripe events (payments, cancellations)

• **Embed Widget**

*   GET `/api/projects/{id}/embed/config` – return the embed script and settings

• **Real-Time Updates**

*   WebSocket endpoint `/ws` accepts a project ID and broadcasts new feedback, votes, and comments in real time

## 5. Hosting Solutions

• **Supabase**

*   Managed PostgreSQL and Auth, auto‐scaling, built‐in backups
*   Handles database, authentication, and real‐time pub/sub out of the box

• **Vercel**

*   Hosts Next.js frontend and API routes
*   Global CDN for low‐latency static assets (widget scripts, dashboard assets)
*   Serverless functions auto‐scale on demand, pay per usage

Benefits:

*   **Reliability**: Both Supabase and Vercel boast 99.9%+ uptime
*   **Scalability**: Zero-config scaling for database and serverless functions
*   **Cost-effectiveness**: Usage‐based billing means small teams pay little until they grow

## 6. Infrastructure Components

• **Load Balancer & CDN**

*   Provided by Vercel’s global network to serve static and dynamic content nearest to users

• **Real-Time Connections**

*   Supabase Realtime uses Postgres replication to push changes, or our own WebSocket server for custom events

• **Caching**

*   Edge caching for static queries on `/api/projects/{id}` using Next.js Incremental Static Regeneration (ISR)
*   HTTP caching headers on embed scripts

• **Backups**

*   Automated daily snapshots of the Postgres database in Supabase

• **Email / Notifications**

*   In-app alerts via API push events

## 7. Security Measures

• **Authentication & Authorization**

*   Supabase Auth issues JWTs with role claims (founder, contributor, moderator)
*   Row‐Level Security (RLS) policies enforce who can read or write each table row

• **Data Encryption**

*   SSL/TLS in transit for all API and database connections
*   Encryption at rest in Supabase

• **Input Validation & Sanitization**

*   All inputs pass through a validation layer (Zod or Yup) before business logic
*   Output encoding to prevent XSS in comments and feedback content

• **Compliance**

*   GDPR‐compliant data deletion (soft delete with `is_deleted`, plus full purge on request)
*   Stripe handles PCI compliance for payments

## 8. Monitoring and Maintenance

• **Logs & Metrics**

*   Vercel logs for function invocations and errors
*   Supabase dashboard for query performance and error logging
*   Basic analytics (<10ms p95) on API route performance

• **Error Tracking**

*   Integration with Sentry or equivalent to capture uncaught exceptions

• **Backups & Recovery**

*   Daily DB snapshots with 7‐day retention
*   Manual point-in-time restore if needed

• **Maintenance Practices**

*   Dependency updates on a biweekly schedule
*   Security patching within 48 hours of vulnerability disclosure
*   Monthly review of RLS policies and IAM roles

## 9. Conclusion and Overall Backend Summary

Our backend is a serverless, fully managed system built on Supabase and Vercel. It leverages PostgreSQL for structured data, real-time capabilities for instant feedback, and Next.js API routes for flexible business logic. We integrate OpenAI for AI­-powered suggestions and Stripe for seamless billing. Security, scalability, and cost-effectiveness are baked into every layer. From a solo founder’s first roadmap to a growing community of contributors, this architecture will grow with our users and keep maintenance low. The unique combination of public-first design, real-time updates, and AI-driven insights sets DefaultPublic apart as a focused SaaS tool for builders in public.
